# -*- coding: utf-8 -*-
"""ppi_app.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17kVzRAosORn4pF2ah5-9C433uoGmmRwp

# Requirements
"""


"""# Libraries"""

import pickle

import numpy as np
import pandas as pd

from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split 
from sklearn.linear_model import LinearRegression

import anvil.server

import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

import psycopg2
import sqlalchemy
from sqlalchemy.sql import text
import urllib.parse
from sqlalchemy.orm import close_all_sessions
from sqlalchemy.pool import NullPool

#from google.colab import drive
#drive.mount('/content/drive/')

"""# Anvil Connection"""

anvil.server.connect("2PKDVT3KVG7CT3I3Y3CSUNRN-63Q2A4ZEHPJO67CU")


"""# Input Data"""

@anvil.server.callable
def ppi_predict_team():

  engine = sqlalchemy.create_engine('postgresql://wwigvksw:RAM3qD0eF20dKedezTCFKW7reTQbVsto@ruby.db.elephantsql.com:5432/wwigvksw', pool_pre_ping=True, poolclass = NullPool)
  conn = engine.connect()
  df = pd.read_sql_query('SELECT * FROM INPUT',con=conn)

  df_ = df.drop(labels = ['index', 'N', 'MID'], axis = 'columns')
  df_['PT'] = df_['PT'].apply(lambda x : float(x[:-1]))
  df_['OUT'] = np.where(df_['OUT'] == 'W', 1, 0)
  df__ = df

  ppi_predictions = []

  scaler = MinMaxScaler()

  for i in range(0, df_.shape[0]):

    profile = df_.iloc[i]['P']
    input_values_i = np.array(df_.iloc[i][:-1].values, dtype=float)

    if(profile == 'Attacker'):

      df_scaled = scaler.fit_transform(df_[['PT', 'G', 'A', 'KP', 'CP', 'SR', 'PP', 'T', 'SH', 'SG', 'C', 'TO', 'R', 'F', 'YC', 'RC', 'SV', 'CS', 'O', 'OUT']])

      # load the model from disk
      path = './Checkpoints/'
      filename = 'ppi_model_attacker.sav'
      ppi_model = pickle.load(open(path + filename, 'rb'))

      prediction = ppi_model.predict([input_values_i])

    elif(profile == 'Defender'):

      df_scaled = scaler.fit_transform(df_[['PT', 'G', 'A', 'KP', 'CP', 'SR', 'PP', 'T', 'SH', 'SG', 'C', 'TO', 'R', 'F', 'YC', 'RC', 'SV', 'CS', 'O', 'OUT']])

      # load the model from disk
      path = './Checkpoints/'
      filename = 'ppi_model_defender.sav'
      ppi_model = pickle.load(open(path + filename, 'rb'))

      prediction = ppi_model.predict([input_values_i])


    elif(profile == 'Midfielder'):

      df_scaled = scaler.fit_transform(df_[['PT', 'G', 'A', 'KP', 'CP', 'SR', 'PP', 'T', 'SH', 'SG', 'C', 'TO', 'R', 'F', 'YC', 'RC', 'SV', 'CS', 'O', 'OUT']])

      # load the model from disk
      path = './Checkpoints/'
      filename = 'ppi_model_midfielder.sav'
      ppi_model = pickle.load(open(path + filename, 'rb'))

      prediction = ppi_model.predict([input_values_i])


    else:

      df_scaled = scaler.fit_transform(df_[['PT', 'G', 'A', 'KP', 'CP', 'SR', 'PP', 'T', 'SH', 'SG', 'C', 'TO', 'R', 'F', 'YC', 'RC', 'SV', 'CS', 'O', 'OUT']])

      # load the model from disk
      path = './Checkpoints/'
      filename = 'ppi_model_goalkeeper.sav'
      ppi_model = pickle.load(open(path + filename, 'rb'))

      prediction = ppi_model.predict([input_values_i])

    ppi_predictions.append(prediction[0])



  df_['PPI'] = ppi_predictions
  df_['N'] = df__['N']

  df_ = df_.groupby(['N']).mean().reset_index(drop = False)
  df_['P'] = [df__[df__['N'] == name]['P'].unique()[0] for name in df_['N']]

  df_ = df_.sort_values(by = 'PPI', axis = 'index', ascending = False).reset_index(drop = False).drop(labels = 'index', axis = 'columns').reset_index(drop = False).rename(columns = {'index':'Rank'})
  df_['Rank'] = df_['Rank'].apply(lambda x: x+1)
  df_ = df_[['N', 'P', 'PPI', 'Rank']].rename({'N':'Name', 'P':'Profile'}, axis = 'columns')

  df_.to_sql('output', con=conn, if_exists = 'replace')
  conn.close()
  engine.dispose()

  close_all_sessions()
  

"""# Availability Forever"""

anvil.server.wait_forever()
